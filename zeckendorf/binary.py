"""
Tools for converting Zeckendorf representations to and from binary
integers and strings.

Each of the "from" methods in this module takes in an object (of various
types) and returns an integer, representing a binary number. Each of the
"to" methods does the reverse, taking in an integer and converting it
to an object of various types.

Methods prefixed with "str" do the same thing but with bitstrings
instead of integers.
"""
from zeckendorf.base import _fibs, _negafibs, negazeck, zeck


def _ordered_in(contained, container):
    """
    A version of (item in container for item in contained) for the case
    where container is an iterable whose items appear in the same order
    as they do in contained.

    :param contained: an iterable of values that would go on the left
        side of the "in" operator.
    :param container: an iterable that would go on the right side of
        the "in" operator. Doesn't have to be a container.
    :type contained: Iterable
    :type container: Iterable
    :return: an iterator of True and False values.
    :rtype: Iterator[bool]
    """
    for item in container:
        for nxt in contained:
            if nxt == item:
                yield True
                break
            yield False


def fromiter(iterable):
    """
    Construct a binary number from a finite iterable, where the ith bit
    from the right is the truth value of the iterable's ith item.
    
    :param iterable: any iterable, usually one with boolean values.
    :type iterable: Iterable
    :return: the binary number.
    :rtype: int
    """
    return sum(1 << i for i, obj in enumerate(iterable) if obj)


def fromzeck(zeck, nega=False):
    """
    Construct a binary number from a finite stream of Fibonacci numbers,
    where the ith bit from the right is 1 if and only if the (i + 2)th
    Fibonacci number appears in the stream.
    
    :param zeck: a stream of Fibonacci numbers ordered from largest to
        smallest, usually one generated by zeckendorf.base.zeck().
    :param nega: whether to take in nega-Fibonacci numbers, such as may
        be generated by zeckendorf.base.negazeck(), instead of regular
        ones. If so, there will be an extra bit on the right
        corresponding to the lone 1 in the nega-Fibonacci sequence.
    :type zeck: Iterable[int]
    :type nega: bool
    :return: the binary number.
    :rtype: int
    """
    if nega:
        fibs = _negafibs()
        next(fibs)  # ignore 0 and start with 1, -1, 2, ...
    else:
        fibs = _fibs()
        next(fibs), next(fibs)  # ignore 0, 1 and start with 1, 2, ...
    return fromiter(_ordered_in(fibs, reversed(tuple(zeck))))


def str_fromzeck(zeck, nega=False):
    """
    Construct a string of bits from a finite stream of Fibonacci
    numbers, where the ith bit from the right is 1 if and only if the
    (i + 2)th Fibonacci number appears in the stream.
    
    :param zeck: a stream of Fibonacci numbers ordered from largest to
        smallest, usually one generated by zeckendorf.base.zeck().
    :param nega: whether to take in nega-Fibonacci numbers, such as may
        be generated by zeckendorf.base.negazeck(), instead of regular
        ones. If so, there will be an extra bit on the right
        corresponding to the lone 1 in the nega-Fibonacci sequence.
    :type zeck: Iterable[int]
    :type nega: bool
    :return: the string of bits.
    :rtype: str
    """
    return f'{fromzeck(zeck, nega=nega):b}'


def fibcode_fromzeck(zeck, nega=False):
    """
    Construct a Fibonacci code word for a particular Zeckendorf
    representation.

    A Fibonacci code word is the bitstring of a Zeckendorf
    representation, but reversed and with an extra "1" on the end. The
    Fibonacci code is a variable-length Huffman code where "11" appears
    at the end of a word and nowhere else.

    :param zeck: a stream of Fibonacci numbers ordered from largest to
        smallest, usually one generated by zeckendorf.base.zeck().
    :param nega: whether to take in nega-Fibonacci numbers, such as may
        be generated by zeckendorf.base.negazeck(), instead of regular
        ones. If so, there will be an extra bit on the left
        corresponding to the lone 1 in the nega-Fibonacci sequence.
    :type zeck: Iterable[int]
    :type nega: bool
    :return: the Fibonacci code word.
    :rtype: str
    """
    return f'{str_fromzeck(zeck, nega=nega)[::-1]}1'


def fromint(n, nega=False):
    """
    Construct a binary number from the Zeckendorf representation of n.
    
    :param n: an integer.
    :param nega: whether to use the nega-Zeckendorf representation in
        lieu of the regular one. Negative values of n are only allowed
        in this case.
    :type n: int
    :type nega: bool
    :return: the binary number.
    :rtype: int
    """
    return fromzeck((negazeck if nega else zeck)(n), nega=nega)


def str_fromint(n, nega=False):
    """
    Construct a string of bits from the Zeckendorf representation of n.
    
    :param n: an integer.
    :param nega: whether to use the nega-Zeckendorf representation in
        lieu of the regular one. Negative values of n are only allowed
        in this case.
    :type n: int
    :type nega: bool
    :return: the string of bits.
    :rtype: str
    """
    return str_fromzeck((negazeck if nega else zeck)(n), nega=nega)


def fibcode_fromint(n, nega=False):
    """
    Return the Fibonacci code word corresponding to a certain positive
    integer.

    A Fibonacci code word is the bitstring of a Zeckendorf
    representation, but reversed and with an extra "1" on the end. The
    Fibonacci code is a variable-length Huffman code where "11" appears
    at the end of a word and nowhere else.

    :param n: an integer.
    :param nega: whether to generate a nega-Fibonacci code word instead
        of a regular one. Negative values of n are only allowed in this
        case.
    :type n: int
    :type nega: bool
    :return: the Fibonacci code word.
    :rtype: str
    """
    if n == 0:
        raise ValueError("0 cannot be converted to a Fibonacci code word")
    return fibcode_fromzeck((negazeck if nega else zeck)(n), nega=nega)


def toiter(binary):
    """
    Iterate over the bits of a binary number from right to left.
    
    :param binary: a binary number.
    :type binary: int
    :return: an iterator of True and False values.
    :rtype: Iterator[bool]
    """
    while binary > 0:
        yield bool(binary % 2)
        binary >>= 1


def tozeck(binary, nega=False):
    """
    Iterate over the Fibonacci numbers F_(i+2) for which the ith bit
    from the right of a binary number is 1.
    
    :param binary: a binary number.
    :param nega: whether to return a nega-Zeckendorf representation
        instead of a regular one.
    :type binary: int
    :type nega: bool
    :return: a stream of Fibonacci numbers from largest to smallest,
        such as may be generated by zeckendorf.base.zeck().
    :rtype: Iterator[int]
    """
    if nega:
        fibs = _negafibs()
        next(fibs)  # ignore 0 and start with 1, -1, 2, ...
    else:
        fibs = _fibs()
        next(fibs), next(fibs)  # ignore 0, 1 and start with 1, 2, ...
    return reversed([fib for bit, fib in zip(toiter(binary), fibs) if bit])


def str_tozeck(bitstr, nega=False):
    """
    Iterate over the Fibonacci numbers F_(i+2) for which the ith bit 
    from the right of the string of bits is 1.
    
    :param bitstr: a string of bits.
    :param nega: whether to return a nega-Zeckendorf representation
        instead of a regular one.
    :type bitstr: str
    :type nega: bool
    :return: a stream of Fibonacci numbers from largest to smallest,
        such as may be generated by zeckendorf.base.zeck().
    :rtype: Iterator[int]
    """
    return tozeck(int(bitstr, base=2), nega=nega)


def fibcode_tozeck(codeword, nega=False):
    """
    Iterate over the Zeckendorf representation corresponding to a
    particular Fibonacci code word.

    :param codeword: a Fibonacci code word.
    :param nega: whether to take in a nega-Fibonacci code word instead
        of a regular one.
    :type codeword: str
    :type nega: bool
    :return: a stream of Fibonacci numbers from largest to smallest,
        such as may be generated by zeckendorf.base.zeck().
    :rtype: Iterator[int]
    """
    return tozeck(int(codeword[-2::-1], base=2), nega=nega)


def toint(binary, nega=False):
    """
    Interpret a binary number as a Zeckendorf representation of an
    integer, and return that integer.
    
    :param binary: a binary number.
    :param nega: whether to interpret the binary number as a
        nega-Zeckendorf representation instead of a regular one.
    :type binary: int
    :type nega: bool
    :return: the integer.
    :rtype: int
    """
    return sum(tozeck(binary, nega=nega))


def str_toint(bitstr, nega=False):
    """
    Interpret a string of bits as a Zeckendorf representation of an
    integer, and return that integer.

    :param bitstr: a string of bits.
    :param nega: whether to interpret the string of bits as a
        nega-Zeckendorf representation instead of a regular one.
    :type bitstr: str
    :type nega: bool
    :return: the integer.
    :rtype: int
    """
    return sum(str_tozeck(bitstr, nega=nega))


def fibcode_toint(codeword, nega=False):
    """
    Convert a Fibonacci code word to the integer it represents.

    :param codeword: a Fibonacci code word.
    :param nega: whether to take in a nega-Fibonacci code word instead
        of a regular one.
    :type codeword: str
    :type nega: bool
    :return: the integer.
    :rtype: int
    """
    return sum(fibcode_tozeck(codeword, nega=nega))


if __name__ == '__main__':
    # example: print bitstrings for Zeckendorf representations from 0-99
    [(print(n, '=>', str_fromint(n))) for n in range(100)]
